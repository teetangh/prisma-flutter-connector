# v0.2.5 - Select Specific Fields

**Version**: 0.2.5
**Status**: Planned
**Priority**: P0 (High)

## Overview

This release adds the ability to select specific columns in queries instead of always using `SELECT *`. This reduces network overhead, improves query performance, and enables selecting specific fields from related tables.

## Problem Statement

Currently, all `findMany`, `findUnique`, and `findFirst` queries generate `SELECT *`:

```sql
SELECT * FROM "Product" WHERE "isActive" = $1
```

This has several drawbacks:
1. **Network overhead**: Fetches all columns even when only a few are needed
2. **Memory usage**: Loads unnecessary data into memory
3. **No relation field selection**: Cannot select specific fields from JOINed tables
4. **Post-processing required**: Must filter fields after fetching

## Solution

Enhance `JsonQueryBuilder` with a `selectFields()` method that generates specific SELECT columns.

## API Design

### Basic Usage: Select Scalar Fields

```dart
final query = JsonQueryBuilder()
    .model('Product')
    .action(QueryAction.findMany)
    .selectFields(['id', 'name', 'price', 'rating'])
    .where({'isActive': true})
    .build();

final compiler = SqlCompiler(provider: 'postgresql');
final sql = compiler.compile(query);
// SELECT "id", "name", "price", "rating" FROM "Product" WHERE "isActive" = $1
```

### Advanced Usage: Dot Notation for Related Fields

```dart
final query = JsonQueryBuilder()
    .model('Product')
    .action(QueryAction.findMany)
    .selectFields(['id', 'name', 'category.name', 'category.id'])
    .include({'category': true})
    .build();

final compiler = SqlCompiler(provider: 'postgresql', schema: schema);
final sql = compiler.compile(query);
// SELECT "t0"."id", "t0"."name", "t1"."name" AS "category_name", "t1"."id" AS "category_id"
// FROM "Product" "t0"
// LEFT JOIN "Category" "t1" ON "t1"."id" = "t0"."categoryId"
```

### With Existing select() Method (Backward Compatible)

The existing `.select(Map)` syntax continues to work:

```dart
// Old syntax (still works)
.select({'id': true, 'name': true})

// New syntax (preferred)
.selectFields(['id', 'name'])
```

## Implementation Details

### Files Modified

1. **`lib/src/runtime/query/json_protocol.dart`**
   - Add `List<String>? _selectFields` property
   - Add `selectFields(List<String> fields)` method
   - Update `build()` to include select fields in arguments

2. **`lib/src/runtime/query/sql_compiler.dart`**
   - Update `_compileSelect()` to handle List<String> select fields
   - Add `_parseFieldWithAlias()` for dot notation parsing
   - Generate proper column aliases for related fields
   - Use table aliases when relations are included

3. **`test/unit/sql_compiler_test.dart`**
   - Add test group for select specific fields
   - Test scalar field selection
   - Test dot notation with relations
   - Test backward compatibility with Map syntax

### Query Argument Structure

```json
{
  "modelName": "Product",
  "action": "findMany",
  "query": {
    "arguments": {
      "select": ["id", "name", "price"],
      "where": {"isActive": true}
    }
  }
}
```

### Column Aliasing Strategy

When selecting fields from related tables, use this aliasing convention:
- `category.name` → `"category_name"`
- `category.id` → `"category_id"`
- `user.profile.bio` → `"user_profile_bio"`

## Test Cases

### 1. Basic Scalar Selection

```dart
test('select specific scalar fields', () {
  final query = JsonQueryBuilder()
      .model('Product')
      .action(QueryAction.findMany)
      .selectFields(['id', 'name', 'price'])
      .build();

  final compiler = SqlCompiler(provider: 'postgresql');
  final sql = compiler.compile(query);

  expect(sql.sql, contains('SELECT "id", "name", "price"'));
  expect(sql.sql, isNot(contains('SELECT *')));
});
```

### 2. Dot Notation with Relations

```dart
test('select fields from relations with dot notation', () {
  final schema = SchemaRegistry();
  schema.registerModel(ModelSchema(
    name: 'Product',
    tableName: 'Product',
    fields: {
      'id': FieldInfo(name: 'id', columnName: 'id', type: 'String', isId: true),
      'name': FieldInfo(name: 'name', columnName: 'name', type: 'String'),
      'categoryId': FieldInfo(name: 'categoryId', columnName: 'categoryId', type: 'String'),
    },
    relations: {
      'category': RelationInfo(
        name: 'category',
        type: RelationType.manyToOne,
        targetModel: 'Category',
        foreignKey: 'categoryId',
        references: ['id'],
      ),
    },
  ));

  final query = JsonQueryBuilder()
      .model('Product')
      .action(QueryAction.findMany)
      .selectFields(['id', 'name', 'category.name'])
      .include({'category': true})
      .build();

  final compiler = SqlCompiler(provider: 'postgresql', schema: schema);
  final sql = compiler.compile(query);

  expect(sql.sql, contains('"category_name"'));
  expect(sql.sql, contains('LEFT JOIN'));
});
```

### 3. Empty Select = SELECT *

```dart
test('no selectFields returns SELECT *', () {
  final query = JsonQueryBuilder()
      .model('Product')
      .action(QueryAction.findMany)
      .where({'isActive': true})
      .build();

  final compiler = SqlCompiler(provider: 'postgresql');
  final sql = compiler.compile(query);

  expect(sql.sql, contains('SELECT *'));
});
```

### 4. Mixed with Other Clauses

```dart
test('selectFields works with where, orderBy, pagination', () {
  final query = JsonQueryBuilder()
      .model('Product')
      .action(QueryAction.findMany)
      .selectFields(['id', 'name', 'price'])
      .where({'isActive': true})
      .orderBy({'price': 'asc'})
      .take(10)
      .skip(0)
      .build();

  final compiler = SqlCompiler(provider: 'postgresql');
  final sql = compiler.compile(query);

  expect(sql.sql, contains('SELECT "id", "name", "price"'));
  expect(sql.sql, contains('WHERE'));
  expect(sql.sql, contains('ORDER BY'));
  expect(sql.sql, contains('LIMIT'));
});
```

## Backward Compatibility

| Scenario | Behavior |
|----------|----------|
| No `.select()` or `.selectFields()` | `SELECT *` (unchanged) |
| `.select({'id': true, 'name': true})` | `SELECT "id", "name"` (unchanged) |
| `.selectFields(['id', 'name'])` | `SELECT "id", "name"` (new) |
| Both `.select()` and `.selectFields()` | `.selectFields()` takes precedence |

## Database Provider Support

| Provider | Status | Notes |
|----------|--------|-------|
| PostgreSQL | ✅ Full support | Quoted identifiers, aliases |
| Supabase | ✅ Full support | Same as PostgreSQL |
| MySQL | ✅ Full support | Backtick identifiers |
| SQLite | ✅ Full support | Quoted identifiers |

## Migration Guide

### Before (v0.2.4)

```dart
// Cannot select specific fields, always SELECT *
final results = await executor.executeQueryAsMaps(
  JsonQueryBuilder()
      .model('Product')
      .action(QueryAction.findMany)
      .where({'isActive': true})
      .build(),
);

// Post-process to get only needed fields
final simplified = results.map((r) => {
  'id': r['id'],
  'name': r['name'],
}).toList();
```

### After (v0.2.5)

```dart
// Select only the fields you need
final results = await executor.executeQueryAsMaps(
  JsonQueryBuilder()
      .model('Product')
      .action(QueryAction.findMany)
      .selectFields(['id', 'name'])
      .where({'isActive': true})
      .build(),
);

// Results already contain only id and name
```

## Performance Impact

Selecting specific fields reduces:
- **Network transfer**: Only selected columns sent over the wire
- **Memory usage**: Less data loaded into Dart objects
- **Database load**: Optimizer can use covering indexes

For tables with many columns or large text/blob fields, this can significantly improve query performance.

## Related Features

- **v0.2.4**: Relation filtering with EXISTS subqueries
- **v0.2.3**: NULLS LAST/FIRST ordering
- **Planned v0.2.6**: Aggregations (COUNT, AVG, SUM, MIN, MAX)
- **Planned v0.2.7**: GROUP BY support
