────────────────────────────────────────────────────────────────────────────────────
Ready to code?

Here is Claude's plan:
╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌
Plan: Transform Prisma Flutter Connector into True Dart ORM

Overview

Transform the connector from a GraphQL client generator into a true Prisma-style
ORM that works natively in Dart, similar to how Prisma works in TypeScript/Next.js.

Architecture Strategy

Approach: Adapter-Based Direct Database Access

- Generate Dart client code that connects directly to databases (like Prisma
  Client)
- Use database adapter pattern (similar to @prisma/adapter-\*)
- Support multiple databases through adapters (PostgreSQL, MySQL, SQLite, Supabase)
- No backend required for simple apps (direct DB connection)
- Optional: Keep GraphQL mode for complex apps

Implementation Phases

Phase 1: Core Adapter Infrastructure (Foundation)

1.1 Create Database Adapter Interface

- Define SqlDriverAdapter abstract class (from Prisma's adapter interface)
- Define SqlQuery, SqlResultSet, Transaction types
- Define ConnectionInfo for database metadata

  1.2 Implement PostgreSQL Adapter

- Use postgres package (Dart's native PostgreSQL driver)
- Implement queryRaw(), executeRaw(), startTransaction()
- Handle type conversion (PostgreSQL ↔ Dart)
- Connection pooling

  1.3 Implement Supabase Adapter

- Use Supabase's REST API or direct PostgreSQL connection
- Implement same SqlDriverAdapter interface
- Handle Supabase-specific auth/RLS

  1.4 Implement SQLite Adapter

- Use sqflite package (perfect for mobile!)
- Enable offline-first Flutter apps
- Local database support

Phase 2: Query Building System

2.1 JSON Protocol Implementation

- Parse Prisma's DMMF (Data Model Meta Format)
- Build JSON protocol queries from Dart API calls
- Serialize query arguments with type information

  2.2 Query Compiler Options

Option A: Dart-Native SQL Compiler (MVP - Start Here)

- Implement simplified query compiler in pure Dart
- Translate JSON protocol → SQL
- Handle WHERE, SELECT, JOIN, ORDER BY, etc.
- Support common Prisma query patterns

Option B: WASM Integration (Advanced - Future)

- Load Prisma's query_compiler_bg.wasm via Dart FFI
- Use existing battle-tested compiler
- Better query optimization

  2.3 Query Interpreter

- Interpret query plans
- Execute SQL via adapters
- Handle result serialization

Phase 3: Code Generation Refactor

3.1 Update Generator to Produce Direct DB Client

- Modify bin/generate.dart to generate adapter-based code
- Generate client with configurable adapters
- Keep Freezed models (already good)

  3.2 Generated Client Structure
  // Generated code structure:
  final prisma = PrismaClient(
  adapter: PostgresAdapter(
  connection: PostgreSQLConnection(/_..._/),
  ),
  );

// Use like Prisma in TypeScript:
final user = await prisma.user.findUnique(where: {'id': '123'});
final products = await prisma.product.findMany(
where: {'price': {'lte': 100}},
orderBy: {'createdAt': 'desc'},
);

3.3 Type System

- Generate input types (CreateInput, UpdateInput, WhereInput)
- Generate filter types (equals, in, contains, etc.)
- Handle special types (DateTime, Json, Decimal, Bytes)

Phase 4: Transaction & Connection Management

4.1 Transaction Manager

- Interactive transactions ($transaction())
- Rollback on errors
- Timeout handling

  4.2 Connection Management

- Connection pooling
- Health checks
- Auto-reconnection

Phase 5: Supabase Example Implementation

5.1 Create Dart Frog Backend Example (Optional showcase)

- Simple REST API using Dart Frog
- Use the new direct DB adapter
- Demonstrate server-side Dart usage

  5.2 Create Flutter Frontend Example

- Mobile app using SQLite adapter (offline-first)
- Sync data with Supabase when online
- Demonstrate direct Supabase adapter usage
- CRUD operations on Domain, Newsletter, Topic models

  5.3 Testing

- Unit tests for adapters
- Integration tests with real Supabase database
- Smoke tests for CRUD operations

Specific File Changes

New Files to Create:

1.  lib/src/runtime/adapters/adapter_interface.dart
2.  lib/src/runtime/adapters/postgres_adapter.dart
3.  lib/src/runtime/adapters/supabase_adapter.dart
4.  lib/src/runtime/adapters/sqlite_adapter.dart
5.  lib/src/runtime/query/query_builder.dart
6.  lib/src/runtime/query/query_compiler.dart
7.  lib/src/runtime/query/query_interpreter.dart
8.  lib/src/runtime/query/json_protocol.dart
9.  lib/src/runtime/transaction/transaction_manager.dart
10. lib/src/runtime/dmmf/dmmf_parser.dart

Files to Modify:

1.  bin/generate.dart - Update to generate adapter-based client
2.  lib/src/generator/client_generator.dart - New client template
3.  lib/src/generator/api_generator.dart - Generate adapter-aware API
4.  pubspec.yaml - Add database driver dependencies

Examples:

1.  examples/supabase_example/ - Refactor to use direct connection
2.  examples/sqlite_mobile/ - NEW: Offline-first mobile example
3.  examples/dart_frog_backend/ - NEW: Server-side Dart example

Migration Strategy

Backward Compatibility

- Keep GraphQL mode as an adapter option
- Users can choose: direct DB, GraphQL, or HTTP proxy
- Gradual migration path

// New: Direct DB
final prisma = PrismaClient(adapter: PostgresAdapter(/_..._/));

// Old: GraphQL (still supported)
final prisma = PrismaClient(
adapter: GraphQLAdapter(endpoint: 'http://...'),
);

Success Criteria

✅ Can connect directly to PostgreSQL/MySQL/SQLite from Dart✅ Type-safe API
matching Prisma TypeScript DX✅ No backend required for simple apps✅ Works offline
with SQLite adapter✅ Supabase example demonstrates real-world usage✅ Passes CRUD
smoke tests✅ Documentation updated

Timeline Estimate

- Phase 1 (Adapters): 3-5 days
- Phase 2 (Query System): 5-7 days
- Phase 3 (Code Gen): 3-4 days
- Phase 4 (Transactions): 2-3 days
- Phase 5 (Examples): 2-3 days

Total: ~15-22 days for MVP with core features

Questions to Confirm

1.  Start with Dart-native query compiler (simpler) or attempt WASM integration
    (more complex)?
2.  For Supabase example: Direct PostgreSQL connection or use Supabase SDK?
3.  Priority order: PostgreSQL → SQLite → MySQL adapters?
    ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌

Would you like to proceed?

❯ 1. Yes, and auto-accept edits 2. Yes, and manually approve edits 3. No, keep planning

ctrl-g to edit plan in code
